name: apigw-automation

on:
  pull_request:
    types: [opened, edited, reopened, synchronize, closed]

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number }}
  cancel-in-progress: true

jobs:
  automation:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        #environment: [dev, test, qa, uat, prod, vapt]
        environment: [dev, qa]

    env:
      ENVIRONMENT: ${{ matrix.environment }}
      PR_NUMBER: ${{ github.event.number }}


      # ========================================
      # PR NOT CLOSED ON INTEROP-CORE-DEPLOYMENT
      # ========================================

    steps:
      - name: Checkout local repository
        uses: actions/checkout@v4
        with:
          # Esempio: Branch PR: develop → 1.1.0 → develop (git diff HEAD~1 vede il revert)
          #          Merge commit: in caso di revert non vede differenze
          ref: ${{ github.head_ref }}
          fetch-depth: 2

      - name: Detect relevant changes (diff + reverts)
        # Il workflow viene triggerato anche in presenza qualsiasi modifica al repo,
        # mi serve un controllo per verificare se ci sono delle modifiche ai file images.yaml
        if: github.event.action != 'closed'
        id: detect-changes
        run: |
          set -euo pipefail
          git fetch origin main

          echo "Checking for changes in commons/*/images.yaml ..."

          # Rileva se l'ultimo commit ha modificato i file images.yaml
          LAST_COMMIT_CHANGES=false

          # Controllo se l'ultimo commit ha interessato i file images.yaml
          if git diff --name-only HEAD~1 HEAD | grep -E "^commons/.*/images\.yaml$"; then
            LAST_COMMIT_CHANGES=true
            echo "Last commit modified images.yaml files - proceeding with workflow"
            echo "has_relevant_changes=true" >> $GITHUB_OUTPUT
          else
            echo "Last commit did not modify images.yaml files - stopping workflow"
            echo "has_relevant_changes=false" >> $GITHUB_OUTPUT
            exit 0
          fi

      - name: Extract microservice tags
        if: github.event.action != 'closed' && steps.detect-changes.outputs.has_relevant_changes == 'true'
        id: extract-tags
        run: |
          set -euo pipefail

          # DEFINIZIONE DEI SERVIZI ESPOSTI
          services_to_watch=("authorization-server-node" "backend-for-frontend" "api-gateway" "m2m-gateway")
          echo "Exposed services: ${services_to_watch[*]}"

          path_metadata=".apigw-automation-meta"
          mkdir -p "$path_metadata"

          # FILE DELL'ENV CORRENTE
          file="commons/${ENVIRONMENT}/images.yaml"

          # VERIFICO SE IL FILE ESISTE
          if [ ! -f "$file" ]; then
            echo "ERROR: File $file not found for environment ${ENVIRONMENT}."
            exit 1
          fi

          # definisco il file dei tag correnti
          tags_file="$path_metadata/tags-${ENVIRONMENT}.yaml"
          # definisco la variabile has_services_to_process per tenere traccia dei servizi esposti
          has_services_to_process=false

          echo "=== Extracting microservice tags for ${ENVIRONMENT} ==="

          # CICLO SU TUTTI I SERVIZI ESPOSTI PER ESTRARRE I TAG CORRENTI
          for svc in "${services_to_watch[@]}"; do
            # RECUPERO IL TAG CORRENTE
            tag_current=$(yq '.images.microservices["'"$svc"'"].tag' "$file" 2>/dev/null || echo "null")

            # VERIFICO CHE IL SERVIZIO ESISTA
            if [ "$tag_current" == "null" ]; then
              echo "WARNING: Service $svc not found in $file - skipping service"
              continue
            fi

            # VERIFICO CHE IL TAG NON SIA VUOTO
            if [ -z "$tag_current" ]; then
              echo "ERROR: Service $svc has empty tag in $file"
              exit 1
            fi

            # CREO IL FILE CON I TAG CORRENTI
            # al primo run creo il file e imposto la variabile has_services_to_process a true
            if [ "$has_services_to_process" = false ]; then
              > "$tags_file"
              has_services_to_process=true
            fi
            # aggiungo i tag del servizio corrente al file
            {
              echo "${svc}:"
              echo "  tag: $tag_current"
            } >> "$tags_file"

            # Log del tag corrente per debug
            echo "Service: $svc, Current tag: $tag_current"
          done

          # SE AL TERMINE DEL CICLO FOR NON HO TROVATO SERVIZI VALIDI (HO TROVATO SOLO SERVIZI NON ESPOSTI), STOPPO IL WORKFLOW
          if [ "$has_services_to_process" = false ]; then
            echo "No valid microservices found for ${ENVIRONMENT} - stopping workflow"
            echo "has_valid_services=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Tags extracted for ${ENVIRONMENT}. Tags file: $tags_file"
          echo "tags_file=$tags_file" >> $GITHUB_OUTPUT
          echo "has_valid_services=true" >> $GITHUB_OUTPUT

      - name: Checkout remote repository
        if: github.event.action != 'closed' && steps.detect-changes.outputs.has_relevant_changes == 'true' && steps.extract-tags.outputs.has_valid_services == 'true'
        uses: actions/checkout@a5ac7e51b41094c92402da3b24376905380afc29
        with:
          repository: ${{ vars.INTEROP_INFRA_REPO }}
          token: ${{ secrets.INTEROP_INFRA_REPO_TOKEN }}
          path: interop-infra
          fetch-depth: 0

      - name: Build bot credentials
        if: github.event.action != 'closed' && steps.extract-tags.outputs.has_valid_services == 'true'
        id: bot_creds
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BOT_USER="github-actions[bot]"
          BOT_ENC=$(printf '%s' "$BOT_USER" | jq -sRr @uri)

          BOT_ID=$(curl -s \
            -H "Authorization: Bearer $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            https://api.github.com/users/$BOT_ENC \
            | jq -r .id)

          BOT_EMAIL="${BOT_ID}+${BOT_USER}@users.noreply.github.com"

          echo "BOT_EMAIL=${BOT_EMAIL}" >> $GITHUB_OUTPUT
          echo "BOT_USER=${BOT_USER}" >> $GITHUB_OUTPUT

      - name: Build PR Labels
        if: github.event.action != 'closed' && steps.detect-changes.outputs.has_relevant_changes == 'true' && steps.extract-tags.outputs.has_valid_services == 'true'
        id: build_labels
        env:
          ENVIRONMENT: ${{ matrix.environment }}
        run: |
          set -euo pipefail

          label1="env=$ENVIRONMENT"
          label2="ref_pr=$PR_NUMBER"

          echo "env_label=${label1}" >> $GITHUB_OUTPUT
          echo "prnum_label=${label2}" >> $GITHUB_OUTPUT

      - name: List open PRs
        if: github.event.action != 'closed' && steps.detect-changes.outputs.has_relevant_changes == 'true' && steps.extract-tags.outputs.has_valid_services == 'true'
        id: get_open_prs
        env:
          INTEROP_INFRA_REPO_TOKEN: ${{ secrets.INTEROP_INFRA_REPO_TOKEN }}
        run: |
          set -euo pipefail

          echo "Finding existing PR with label env=${{ matrix.environment }} and ref_pr=${{ github.event.number }}"

          OPEN_PRS=$(curl -sSL \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer $INTEROP_INFRA_REPO_TOKEN" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            https://api.github.com/repos/${{ vars.INTEROP_INFRA_REPO }}/pulls?state=open)

          # find matching prs based on provided labels
          label1="${{ steps.build_labels.outputs.env_label }}"
          label2="${{ steps.build_labels.outputs.prnum_label }}"

          # Estraggo solo le informazioni essenziali delle PR corrispondenti, incluso l'URL
          MATCHING_PR=$(echo $OPEN_PRS | jq -r --arg label_env "${label1}" --arg label_pr "${label2}" \
              '.[] | select(
                (.labels | any(.name == $label_env)) and
                (.labels | any(.name == $label_pr))
              ) | "\(.number): \(.title) | URL: \(.html_url)"')

          if [[ -n "$MATCHING_PR" ]]; then
            echo "Existing PR found: $MATCHING_PR"
            echo "create_pr=false" >> $GITHUB_OUTPUT
          else
            echo "No existing PR found. A new one will be created"
            echo "create_pr=true" >> $GITHUB_OUTPUT
          fi

      - name: Prepare target branch in interop-infra
        if: github.event.action != 'closed' && steps.detect-changes.outputs.has_relevant_changes == 'true' && steps.extract-tags.outputs.has_valid_services == 'true'
        run: |
          set -euo pipefail
          cd interop-infra

          TARGET_BRANCH_FULL=${{ vars.INTEROP_INFRA_TARGET_BRANCH }}-$PR_NUMBER-$ENVIRONMENT

          git fetch origin --prune
          # SE IL BRANCH ESISTE, LO ALLINEO, ALTRIMENTI LO CREO PARTENDO DA MAIN DEL REPO TARGET
          if git ls-remote --exit-code --heads origin "$TARGET_BRANCH_FULL" >/dev/null; then
            echo "Using existing remote branch $TARGET_BRANCH_FULL"
            git checkout "$TARGET_BRANCH_FULL"
            git pull origin "$TARGET_BRANCH_FULL"
          else
            echo "Creating new branch from up-to-date main"
            git checkout -b "$TARGET_BRANCH_FULL"
            git push -u origin "$TARGET_BRANCH_FULL"
          fi

      - name: Update tfvars
        id: update_tfvars
        if: github.event.action != 'closed' && steps.detect-changes.outputs.has_relevant_changes == 'true' && steps.extract-tags.outputs.has_valid_services == 'true'
        run: |
          set -euo pipefail

          TAGS_FILE="${{ steps.extract-tags.outputs.tags_file }}"
          ENV="${{ matrix.environment }}"

          TFVARS_FILE="interop-infra/src/main/core-es1/env/${ENV}/terraform.tfvars"

          # Se il file non esiste, fallisce con errore
          if [ ! -f "$TFVARS_FILE" ]; then
            echo "Error: File $TFVARS_FILE not found in interop-infra repository."
            exit 1
          fi

          # associazione servizio -> variabile da aggiornare
          declare -A service_to_var
          service_to_var=(
            ["api-gateway"]="api_gateway_raw_url"
            ["authorization-server-node"]="authorization_server_node_raw_url"
            ["backend-for-frontend"]="backend_for_frontend_raw_url"
            ["m2m-gateway"]="m2m_gateway_raw_url"
          )
          # associazione servizio -> nome file openapi
          declare -A service_to_file
          service_to_file=(
            ["api-gateway"]="apiGatewayApi.yml"
            ["authorization-server-node"]="authorizationServerApi.yml"
            ["backend-for-frontend"]="bffApi.yml"
            ["m2m-gateway"]="m2mGatewayApi.yml"
          )

          echo "=== Updating terraform.tfvars for environment ${ENV} ==="

          # definisco la variabile che traccia se ci sono stati cambiamenti effettivi
          has_actual_changes=false

          # ciclo i servizi nel file
          for svc in $(yq 'keys | .[]' "$TAGS_FILE"); do

            # popolo il tag corrente per il servizio
            current_tag=$(yq ".\"$svc\".tag" "$TAGS_FILE")
            if [[ "$current_tag" == "null" ]]; then
              continue
            fi

            # popolo la variabile corrispondente al servizio se è vuota vado avanti
            var_name="${service_to_var[$svc]}"
            if [ -z "$var_name" ]; then
              continue
            fi

            # popolo il nome del file openapi, se è vuoto vado avanti
            openapi_file="${service_to_file[$svc]}"
            if [ -z "$openapi_file" ]; then
              continue
            fi

            # nel caso in cui il tag sia develop, uso il branch develop, altrimenti uso il tag sistemando opportunamente la ref
            if [[ "$current_tag" == "develop" ]]; then
              ref="refs/heads/develop"
            else
              ref="refs/tags/${current_tag}"
            fi

            # costruisco la nuova URL raw
            url_raw="https://raw.githubusercontent.com/pagopa/interop-be-monorepo/$ref/packages/api-clients/open-api/$openapi_file"

            #  controllo se la variabile è già presente ed in caso affermativo la aggiorno
            if grep -q "[[:space:]]*$var_name[[:space:]]*=" "$TFVARS_FILE"; then
              # mostro il valore precedente per debug
              old_value=$(grep "[[:space:]]*$var_name[[:space:]]*=" "$TFVARS_FILE" | sed -E 's/.*=[[:space:]]*(.*)/\1/' | tr -d '"')

              echo "Processing $var_name:"
              echo "  OLD: $old_value"
              echo "  NEW: $url_raw"

              # controllo se i valori sono diversi prima di fare la sostituzione
              if [[ "$old_value" != "$url_raw" ]]; then
                echo "Values differ, updating..."
                # sostituisco solo il valore dopo il simbolo = mantenendo tutto il resto
                sed -i -E "s|(.*$var_name[[:space:]]*=)[[:space:]]*.*|\1 \"$url_raw\"|g" "$TFVARS_FILE"
                has_actual_changes=true
              else
                echo "Values are identical, skipping update"
              fi
            else
              # se la variabile non è presente nel file tfvars, restituisco errore
              echo "Error: Variable $var_name not found in $TFVARS_FILE"
              exit 1
            fi
          done

          echo "=== Terraform.tfvars processing completed ==="

          if [[ "$has_actual_changes" == "true" ]]; then
            echo "Found actual changes to apply"
            echo "has_changes=true" >> $GITHUB_OUTPUT
          else
            echo "No actual changes needed - all values are already up-to-date"
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi

      - name: Commit changes to target repo
        id: commit_changes
        if: github.event.action != 'closed' && steps.detect-changes.outputs.has_relevant_changes == 'true' && steps.extract-tags.outputs.has_valid_services == 'true' && steps.update_tfvars.outputs.has_changes == 'true'
        run: |
          set -euo pipefail
          BOT_EMAIL=${{ steps.bot_creds.outputs.BOT_EMAIL }}
          BOT_USER=${{ steps.bot_creds.outputs.BOT_USER }}

          cd interop-infra

          # Configura git con le credenziali del bot
          git config user.name "$BOT_USER"
          git config user.email "$BOT_EMAIL"

          # Configura remote per usare il PAT
          git remote set-url origin "https://x-access-token:${{ secrets.INTEROP_INFRA_REPO_TOKEN }}@github.com/${{ vars.INTEROP_INFRA_REPO }}.git"

          # Commit e push delle modifiche
          REL_TFVARS_FILE="src/main/core-es1/env/${ENVIRONMENT}/terraform.tfvars"
          git add "$REL_TFVARS_FILE"
          git commit -m "Automated update from PR ${{ github.event.number }} (run ${{ github.run_id }})"
          git push

      - name: Check changes in remote repository
        id: check_remote_changes
        if: github.event.action != 'closed' && steps.detect-changes.outputs.has_relevant_changes == 'true' && steps.extract-tags.outputs.has_valid_services == 'true'
        run: |
          set -euo pipefail

          cd interop-infra

          echo "=== Checking differences between current branch and main on interop-infra ==="

          # Aggiorno origin/main di interop-infra
          git fetch origin main

          ENV="${{ matrix.environment }}"
          TFVARS_FILE="src/main/core-es1/env/${ENV}/terraform.tfvars"

          # Verifico che il file terraform.tfvars esista sul branch main di interop-infra
          if ! git show origin/main:$TFVARS_FILE >/dev/null 2>&1; then
            echo "ERROR: File $TFVARS_FILE not found on main branch of interop-infra"
            exit 1
          fi

          # Confronta il file terraform.tfvars corrente con quello su main
          set +e
          git diff --quiet origin/main -- $TFVARS_FILE
          diff_exit_code=$?
          set -e

          # CONTROLLO SE CI SONO DIFFS
          if [ "$diff_exit_code" -eq 0 ]; then
            # NO DIFFS - REVERT
            echo "No differences found between current branch ($CURRENT_BRANCH) and main on interop-infra repository"
            echo "has_remote_changes=false" >> $GITHUB_OUTPUT
            echo "is_revert=true" >> $GITHUB_OUTPUT

            # Mostra i contenuti per debug
            echo "=== Content on main branch ==="
            git show origin/main:$TFVARS_FILE | grep -E "(api_gateway_raw_url|authorization_server_node_raw_url|backend_for_frontend_raw_url|m2m_gateway_raw_url)"
            echo "=== Content on current branch ==="
            grep -E "(api_gateway_raw_url|authorization_server_node_raw_url|backend_for_frontend_raw_url|m2m_gateway_raw_url)" $TFVARS_FILE
          else
            # CI SONO DIFFERENZE
            CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
            echo "Differences found between current branch ($CURRENT_BRANCH) and main on interop-infra repository"
            echo "has_remote_changes=true" >> $GITHUB_OUTPUT
            echo "is_revert=false" >> $GITHUB_OUTPUT

            # Mostra le differenze per debug
            echo "=== DIFFS ==="
            git diff origin/main -- $TFVARS_FILE || true
          fi

      - name: Determine workflow action
        # Determino se procedere con la creazione della PR su interop-infra
        # Caso 1: Aggiornamenti da propagare (bump + revert parziali) -> provo a creare/aggiornare la PR
        # Caso 2: Revert completo -> nessuna PR
        # Caso 3: Edge cases
        id: determine_action
        if: github.event.action != 'closed' && steps.detect-changes.outputs.has_relevant_changes == 'true' && steps.extract-tags.outputs.has_valid_services == 'true'
        run: |
          set -euo pipefail

          # - HAS_CHANGES: se il file terraform.tfvars su interop-infra è stato modificato
          HAS_CHANGES="${{ steps.update_tfvars.outputs.has_changes }}"

          # - IS_REVERT: se i tag su interop-core-deployment sono tornati identici a main di interop-infra
          IS_REVERT="${{ steps.check_remote_changes.outputs.is_revert || 'false' }}"

          # - HAS_REMOTE_CHANGES: se esistono differenze tra branch corrente e main su interop-infra
          HAS_REMOTE_CHANGES="${{ steps.check_remote_changes.outputs.has_remote_changes || 'false' }}"

          echo "=== Workflow action ==="
          echo "Variables in tfvars file on interop-infra have changes: $HAS_CHANGES"
          echo "Revert scenario: $IS_REVERT"
          echo "Has changes (current branch vs main): $HAS_REMOTE_CHANGES"

          # Caso 1: Aggiornamenti da propagare (bump + revert parziali)
          # tag su interop-core-deployment sono cambiati e producono differenze su interop-infra
          # bump dei micro, revert parziali (alcuni servizi revertati, altri no)
          if [[ "$HAS_CHANGES" == "true" && "$HAS_REMOTE_CHANGES" == "true" ]]; then
            echo "Action: Proceed with PR creation/update (has changes + has remote diffs)"
            echo "should_create_pr=true" >> $GITHUB_OUTPUT

          # Caso 2: Revert completo (nessuna PR)
          # Tutti i tag su interop-core-deployment sono tornati identici a main di interop-infra
          # Nessuna PR necessaria perché tutto è già allineato tra i due repository
          elif [[ "$IS_REVERT" == "true" ]]; then
            echo "Action: Revert scenario detected, skip PR creation"
            echo "should_create_pr=false" >> $GITHUB_OUTPUT

          # Caso 3: Edge cases
          else
            echo "WARNING: Possibile edge case"
            echo "should_create_pr=false" >> $GITHUB_OUTPUT
          fi

      - name: Open PR for environment ${{ matrix.environment }}
        id: open_pr
        # Apro una PR su interop-infra se: non ci sono pr aperte e non mi trovo in casi di revert o edge case
        if: steps.determine_action.outputs.should_create_pr == 'true' && steps.get_open_prs.outputs.create_pr == 'true'
        env:
          INTEROP_INFRA_REPO_TOKEN: ${{ secrets.INTEROP_INFRA_REPO_TOKEN }}
        run: |
          set -euo pipefail

          # Costruisco le variabili per il body della PR
          TAGS_FILE="${{ steps.extract-tags.outputs.tags_file }}"

          # Lista dei servizi modificati
          modified_services=""
          for svc in $(yq 'keys | .[]' "$TAGS_FILE"); do
            tag=$(yq ".\"$svc\".tag" "$TAGS_FILE")
            if [[ "$tag" != "null" && -n "$tag" ]]; then
              if [[ -z "$modified_services" ]]; then
                modified_services="$svc"
              else
                modified_services="$modified_services, $svc"
              fi
            fi
          done

          # Informazioni sul commit e sulla PR
          COMMIT_SHA=$(git rev-parse HEAD)
          COMMIT_MSG=$(git log -1 --pretty=format:"%s")
          AUTHOR=$(git log -1 --pretty=format:"%an")
          PR_TITLE="${{ github.event.pull_request.title }}"

          echo "Info collected:"
          echo "  Source PR: #$PR_NUMBER"
          echo "  Source PR title: $PR_TITLE"
          echo "  Environment: $ENVIRONMENT"
          echo "  Modified services: $modified_services"
          echo "  Author: $AUTHOR"
          echo "  Commit ref: $COMMIT_SHA"
          echo "  Workflow run ID: ${{ github.run_id }}"

          # Costruisco il body della PR
          PR_BODY="This PR was automatically created by apigw-automation workflow.\\n\\n"
          PR_BODY+="**Source Repository:** \`interop-core-deployment\`\\n"
          PR_BODY+="**Source PR:** #$PR_NUMBER - $PR_TITLE\\n"
          PR_BODY+="**Environment:** \`$ENVIRONMENT\`\\n"
          PR_BODY+="**Author:** $AUTHOR\\n"
          PR_BODY+="**Commit:** \`${COMMIT_SHA:0:7}\`\\n\\n"
          PR_BODY+="**Modified Services:**\\n"
          PR_BODY+="\`$modified_services\`\\n\\n"
          PR_BODY+="## Automation Info\\n\\n"
          PR_BODY+="- **Workflow:** \`apigw-automation\`\\n"
          PR_BODY+="- **Run ID:** ${{ github.run_id }}\\n"

          # Escape del JSON per curl
          PR_BODY_ESCAPED=$(echo "$PR_BODY" | sed 's/"/\\"/g')

          PR_OPEN_RES=$(curl -sSL \
            -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer $INTEROP_INFRA_REPO_TOKEN" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            https://api.github.com/repos/${{ vars.INTEROP_INFRA_REPO }}/pulls \
            -d "{\"title\":\"[$ENVIRONMENT] Automated update from PR #$PR_NUMBER\",\"head\":\"${{ vars.INTEROP_INFRA_TARGET_BRANCH }}-$PR_NUMBER-$ENVIRONMENT\",\"base\":\"main\",\"body\":\"$PR_BODY_ESCAPED\"}")

          CURL_STATUS=$(echo $PR_OPEN_RES | jq -r '.status')
          CURL_ERRORS=$(echo $PR_OPEN_RES | jq -r '.errors//""')

          # TODO: si potrebbe aggiungere un controllo per intercettare anche altri casi diversi da 404
          # TODO: controllare codici di errore

          if [[ "$CURL_STATUS" == "404" ]] || [[ -n "$CURL_ERRORS" ]]; then
              echo "Failed to create PR: $PR_OPEN_RES"
              exit 1
          else
              echo "PR created successfully $PR_OPEN_RES"
          fi

          PR_NUMBER_CREATED=$(echo $PR_OPEN_RES | jq -r '.number' )
          echo "Target PR Number: $PR_NUMBER_CREATED"

          label1="${{ steps.build_labels.outputs.env_label }}"
          label2="${{ steps.build_labels.outputs.prnum_label }}"

          echo "Applying labels: $label1, $label2"
          LABELING_RESULT=$(curl -sSL \
            -X PUT \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer $INTEROP_INFRA_REPO_TOKEN" \
            https://api.github.com/repos/${{ vars.INTEROP_INFRA_REPO }}/issues/$PR_NUMBER_CREATED/labels \
            -d "{\"labels\": [ \"$label1\", \"$label2\" ] }")

          echo "Labels applied:"
          echo "$LABELING_RESULT"

      # ==============================================
      # MERGE: PR CLOSED ON INTEROP-CORE-DEPLOYMENT (CLEANUP PR/BRANCH on INTEROP-INFRA)
      # ==============================================

      - name: Checkout remote repository - cleanup
        if: github.event.action == 'closed' && github.event.pull_request.merged == true
        uses: actions/checkout@a5ac7e51b41094c92402da3b24376905380afc29
        with:
          repository: ${{ vars.INTEROP_INFRA_REPO }}
          token: ${{ secrets.INTEROP_INFRA_REPO_TOKEN }}
          path: interop-infra
          fetch-depth: 0

      - name: Find and cleanup remote PR for ${{ matrix.environment }}
        # cerco le pr aperte su interop-infra
        # se ci sono diff sui tfvars, non faccio nulla, le mostro e termino il workflow
        # se non ci sono diff sui tfvars, posso procedere con la cancellazione della pr e del branch remoti
        if: github.event.action == 'closed' && github.event.pull_request.merged == true
        env:
          INTEROP_INFRA_REPO_TOKEN: ${{ secrets.INTEROP_INFRA_REPO_TOKEN }}
          MERGED_PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          set -euo pipefail

          echo "=== Looking for remote PR: ref_pr=$MERGED_PR_NUMBER + env=$ENVIRONMENT ==="

          # Cerca la PR specifica sfruttando le label ref_pr e env
          OPEN_PRS=$(curl -sSL \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer $INTEROP_INFRA_REPO_TOKEN" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${{ vars.INTEROP_INFRA_REPO }}/pulls?state=open&per_page=100")

          # Cerca PR (applico la stessa logica dello step List PRs)
          TARGET_PR_LABEL="ref_pr=$MERGED_PR_NUMBER"
          TARGET_ENV_LABEL="env=$ENVIRONMENT"

          PR_INFO=$(echo "$OPEN_PRS" | jq -r --arg target_pr_label "$TARGET_PR_LABEL" --arg target_env_label "$TARGET_ENV_LABEL" '
            .[] |
            select(
              (.labels | any(.name == $target_pr_label)) and
              (.labels | any(.name == $target_env_label))
            ) |
            "\(.number)|\(.head.ref)|\(.title)|\(.html_url)"
          ')

          # controllo, se non ho trovato la PR, esco
          if [[ -z "$PR_INFO" ]]; then
            echo "No remote PR found for $ENVIRONMENT environment"
            echo "This is normal if no remote PR was created for this environment"
            exit 0
          fi

          # Estrai info della PR
          IFS='|' read -r pr_number branch_name title url <<< "$PR_INFO"

          echo "Found remote PR for $ENVIRONMENT:"
          echo "  - PR #$pr_number: $title"
          echo "  - Branch: $branch_name"
          echo "  - URL: $url"

          cd interop-infra

          # Verifica se il branch esiste
          if ! git ls-remote --exit-code --heads origin "$branch_name" >/dev/null 2>&1; then
            echo "WARNING: Branch $branch_name no longer exists, skipping"
            exit 0
          fi

          # Fetch main
          git fetch origin main

          # fetch del branch e verifico l'esistenza, se non esiste skippo
          git fetch origin "$branch_name:$branch_name" 2>/dev/null || {
            echo "WARNING: Could not fetch branch $branch_name, skipping"
            exit 0
          }

          # Controllo differenze per l'ambiente specifico
          tfvars_file="src/main/core-es1/env/${ENVIRONMENT}/terraform.tfvars"

          if [[ ! -f "$tfvars_file" ]]; then
            echo "WARNING: File $tfvars_file not found, skipping"
            exit 0
          fi

          echo "Checking differences for $tfvars_file..."

          # Confronto il file sul branch con quello su main
          if ! git diff --quiet "origin/main:$tfvars_file" "$branch_name:$tfvars_file" 2>/dev/null; then
            echo "Found differences in $tfvars_file - keeping PR open"
            echo "=== Differences ==="
            git diff "origin/main:$tfvars_file" "$branch_name:$tfvars_file"
            exit 0
          fi

          # FASE DI CLEANUP
          echo "No differences found - proceeding with cleanup"

          # Chiudi la PR
          echo "Closing PR #$pr_number..."
          close_result=$(curl -sSL \
            -X PATCH \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer $INTEROP_INFRA_REPO_TOKEN" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${{ vars.INTEROP_INFRA_REPO }}/pulls/$pr_number" \
            -d '{"state":"closed"}')

          close_status=$(echo "$close_result" | jq -r '.state // "error"')
          if [[ "$close_status" == "closed" ]]; then
            echo "Successfully closed PR #$pr_number"

            # Elimina il branch remoto
            echo "Deleting branch $branch_name..."
            if git push origin --delete "$branch_name" 2>/dev/null; then
              echo "Successfully deleted branch $branch_name"
            else
              echo "WARNING: Failed to delete branch $branch_name"
            fi
          else
            echo "ERROR: Failed to close PR #$pr_number: $close_result"
            exit 1
          fi

          echo "Cleanup completed for $ENVIRONMENT environment"
