# .github/workflows/apigw-automation-sub.yaml

name: apigw-automation-sub
permissions:
  contents: read
  pull-requests: write
  issues: write

on:
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
      changes_file_path:
        required: true
        type: string
    secrets:
      INTEROP_INFRA_REPO_TOKEN:
        required: true

env:
  ENVIRONMENT: ${{ inputs.environment }}
  PR_NUMBER: ${{ github.event.number }}

jobs:
  deploy-env:
    runs-on: ubuntu-latest
    steps:
      - name: Print environment
        run: |
          echo "Triggered for environment: ${{ inputs.environment }}"

      - name: Checkout current repository
        uses: actions/checkout@a5ac7e51b41094c92402da3b24376905380afc29
        with:
          fetch-depth: 0

      - name: Checkout remote repository
        uses: actions/checkout@a5ac7e51b41094c92402da3b24376905380afc29
        with:
          repository: ${{ vars.INTEROP_INFRA_REPO }}
          token: ${{ secrets.INTEROP_INFRA_REPO_TOKEN }}
          path: interop-infra
          fetch-depth: 0

      - name: Download changes files artifact
        uses: actions/download-artifact@v4
        with:
          name: changes-yamls
          path: .apigw-automation-meta

      - name: List artifact dir
        run: ls -l .apigw-automation-meta/

      - name: Build bot credentials
        id: bot_creds
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BOT_USER="github-actions[bot]"
          BOT_ENC=$(printf '%s' "$BOT_USER" | jq -sRr @uri)

          BOT_ID=$(curl -s \
            -H "Authorization: Bearer $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            https://api.github.com/users/$BOT_ENC \
            | jq -r .id)

          BOT_EMAIL="${BOT_ID}+${BOT_USER}@users.noreply.github.com

          echo "BOT_EMAIL=${BOT_EMAIL}" >> $GITHUB_OUTPUT
          echo "BOT_USER=${BOT_USER}" >> $GITHUB_OUTPUT

      - name: Build PR Labels
        id: build_labels
        env:
          ENVIRONMENT: ${{ inputs.environment }}
        run: |
          set -euo pipefail

          label1="env=$ENVIRONMENT"
          label2="ref_pr=$PR_NUMBER"

          echo "env_label=${label1}" >> $GITHUB_OUTPUT
          echo "prnum_label=${label2}" >> $GITHUB_OUTPUT

      - name: List open PRs
        id: get_open_prs
        env:
          INTEROP_INFRA_REPO_TOKEN: ${{ secrets.INTEROP_INFRA_REPO_TOKEN }}
        run: |
          set -euo pipefail

          # il query param "state=open" è superfluo, è il default
          OPEN_PRS=$(curl -sSL \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer $INTEROP_INFRA_REPO_TOKEN" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            https://api.github.com/repos/${{ vars.INTEROP_INFRA_REPO }}/pulls?state=open)


          # find matching prs based on provided labels
          label1="${{ steps.build_labels.outputs.env_label }}"
          label2="${{ steps.build_labels.outputs.prnum_label }}"

          MATCHING_PRS=$(echo $OPEN_PRS | jq --arg label_env "${label1}" --arg label_pr "${label2}" \
              '.[] | select(
                (.labels   | any(.name == $label_env)) and
                (.labels   | any(.name == $label_pr))
              )')

          if [[ -n "$MATCHING_PRS" ]]; then
            echo "MATCHING PRs"
            echo $MATCHING_PRS
            echo "create_pr=false" >> $GITHUB_OUTPUT
          else
            echo "No matching PRs, will create a new one"
            echo "create_pr=true" >> $GITHUB_OUTPUT
          fi
      # DEBUG TO REMOVE
      - name: Print changed services for this environment
        run: |
          echo "Changes file path: ${{ inputs.changes_file_path }}"
          if [ -f "${{ inputs.changes_file_path }}" ]; then
            echo "=== Changes for environment: ${{ inputs.environment }} ==="
            cat "${{ inputs.changes_file_path }}"
          else
            echo "No changes file found for env ${{ inputs.environment }}."
          fi

      - name: Update tfvars
        run: |
          set -euo pipefail

          CHANGES_FILE="${{ inputs.changes_file_path }}"
          ENV="${{ inputs.environment }}"

          # TODO: da modificare per adattarlo al repo corretto
          # src/main/core-es1/env/${ENV}/terraform.tfvars
          TFVARS_FILE="src/main/core-es1/env/${ENV}/terraform.tfvars"

          # Se il file non esiste, esci senza errore
          if [ ! -f "$TFVARS_FILE" ]; then
            echo "File $TFVARS_FILE not found."
            exit 0
          fi

          # associazione servizio -> variabile da aggiornare
          declare -A service_to_var
          service_to_var=(
            ["api-gateway"]="api_gateway_raw_url"
            ["authorization-server-node"]="authorization_server_node_raw_url"
            ["backend-for-frontend"]="backend_for_frontend_raw_url"
            ["m2m-gateway"]="m2m_gateway_raw_url"
          )
          # associazione servizio -> nome file openapi
          declare -A service_to_file
          service_to_file=(
            ["api-gateway"]="apiGatewayApi.yml"
            ["authorization-server-node"]="authorizationServerApi.yml"
            ["backend-for-frontend"]="bffApi.yml"
            ["m2m-gateway"]="m2mGatewayApi.yml"
          )

          # debug
          echo "*** tfvars PRIMA ***"
          cat "$TFVARS_FILE"
          echo "********************"

           # ciclo i servizi cambiati nel file
          for svc in $(yq 'keys | .[]' "$CHANGES_FILE"); do

            # popolo il nuovo tag per il servizio se non esiste vado avanti
            new_tag=$(yq ".\"$svc\".after" "$CHANGES_FILE")
            if [[ "$new_tag" == "null" ]]; then
              continue
            fi

            # popolo la variabile corrispondente al servizio se non esiste vado avanti
            var_name="${service_to_var[$svc]}"
            if [ -z "$var_name" ]; then
              continue
            fi

            # popolo il nome del file openapi
            openapi_file="${service_to_file[$svc]}"
            if [ -z "$openapi_file" ]; then
              continue
            fi

              # modificare branch/tag in base alle casistiche; ragionare per tag
            #
            if [[ "$new_tag" == "develop" ]]; then
              ref="refs/heads/develop"
            else
              ref="refs/tags/${new_tag}"
            fi

            #  passo new_tag al nuovo valore della url raw
            url_raw="https://raw.githubusercontent.com/pagopa/interop-be-monorepo/$ref/packages/api-clients/open-api/$openapi_file"

            #  se la variabile è già presente la aggiorno

            # TODO rivedere formattazione/spazi - in questo modo considero anche spazi/tab tra nome variabile e uguale
            if grep -q "^$var_name[[:space:]]*=" "$TFVARS_FILE"; then
              sed -i -E "s|^$var_name[[:space:]]*=.*|$var_name = \"$url_raw\"|g" "$TFVARS_FILE"
              echo "$var_name updated"
            else
              # aggiungo la variabile se non trovata; aggiungo alla fine
              echo "" >> "$TFVARS_FILE"
              echo "$var_name = \"$url_raw\"" >> "$TFVARS_FILE"
              echo "$var_name added"
            fi
          done

          # debug
          echo "=== File tfvars DOPO ==="
          cat "$TFVARS_FILE"

      # - name: Commit changes to target repo
      #   id: commit_changes
      #   run: |
      #     BOT_EMAIL=${{ steps.bot_creds.outputs.BOT_EMAIL }}
      #     BOT_USER=${{ steps.bot_creds.outputs.BOT_USER }}

      #     cd interop-infra

      #     TARGET_BRANCH_FULL=${{ vars.INTEROP_INFRA_TARGET_BRANCH }}-$PR_NUMBER-$ENVIRONMENT
      #     git checkout -b $TARGET_BRANCH_FULL
      #     git pull origin $TARGET_BRANCH_FULL || true

      #     git config user.name "$BOT_USER"
      #     git config user.email "$BOT_EMAIL"

      #     TODO: da modificare
      #     REL_TFVARS_FILE="core-es1/env/${ENV}/terraform.tfvars"
      #     git add "$REL_TFVARS_FILE"

      #     git commit -m "chore: test file for PR opener ${{ github.run_id }}"

      #     git push --set-upstream origin $TARGET_BRANCH_FULL

      # - name: Open PR for environment ${{ inputs.environment }}
      #   id: open_pr
      #   if: ${{ steps.get_open_prs.outputs.create_pr == true }}
      #   env:
      #     INTEROP_INFRA_REPO_TOKEN: ${{ secrets.INTEROP_INFRA_REPO_TOKEN }}
      #   run: |
      #       #TODO
      #       PR_OPEN_RES=$(curl -sSL \
      #       -X POST \
      #       -H "Accept: application/vnd.github+json" \
      #       -H "Authorization: Bearer $INTEROP_INFRA_REPO_TOKEN" \
      #       -H "X-GitHub-Api-Version: 2022-11-28" \
      #       https://api.github.com/repos/${{ vars.INTEROP_INFRA_REPO }}/pulls \
      #       -d '{"title":"['"$ENVIRONMENT"'] TBD Automated update from Repo PR Opener","head":"'${{ vars.INTEROP_INFRA_TARGET_BRANCH }}-$PR_NUMBER-$ENVIRONMENT'","base":"main","body":"TODO This is an example"}')

      #       CURL_STATUS=$(echo $PR_OPEN_RES | jq -r '.status')
      #       CURL_ERRORS=$(echo $PR_OPEN_RES | jq -r '.errors//""')

      #       if [[ "$CURL_STATUS" == "404" ]] || [[ -n "$CURL_ERRORS" ]]; then
      #           echo "Failed to create PR: $PR_OPEN_RES"
      #           exit 1
      #       else
      #           echo "PR created successfully $PR_OPEN_RES"
      #       fi

      #       # Pull requests are a type of issue. Any actions that are available in both pull requests and issues, like managing assignees,
      #       # labels, and milestones, are handled by the REST API to manage issues.
      #       # To perform these actions on pull requests, you must use the issues API endpoints (for example, /repos/{owner}/{repo}/issues/{issue_number}),
      #       # not the pull requests endpoints. For more information, see REST API endpoints for issues.

      #       PR_NUMBER=$(echo $PR_OPEN_RES | jq -r '.number' )
      #       echo "Target PR Number: $PR_NUMBER"

      #       label1="${{ steps.build_labels.outputs.env_label }}"
      #       label2="${{ steps.build_labels.outputs.prnum_label }}"

      #       echo "Applying labels: $label1, $label2"
      #       LABELING_RESULT=$(curl -sSL \
      #         -X PUT \
      #         -H "Accept: application/vnd.github+json" \
      #         -H "Authorization: Bearer $INTEROP_INFRA_REPO_TOKEN" \
      #         -H "X-GitHub-Api-Version: 2022-11-28" \
      #         https://api.github.com/repos/${{ vars.INTEROP_INFRA_REPO }}/issues/$PR_NUMBER/labels \
      #         -d "{\"labels\": [ \"$label1\", \"$label2\" ] }")

      #       echo "Labels applied:"
      #       echo "$LABELING_RESULT"
