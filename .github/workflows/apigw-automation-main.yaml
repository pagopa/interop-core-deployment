name: apigw-automation-main

on:
#   push: # TO ENABLE WHEN READY
#     branches:
#       - main
#       # - develop
#       # tags:
#       #   - '*.*.*'
#       #   - '*.*.*-RC*'
#     paths:
#       - 'commons/*/images.yaml'
    workflow_dispatch: # TO REMOVE WHEN PULL_REQUEST IS ENABLED

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      envs_changed: ${{ steps.check-changes.outputs.envs_changed }}
      any_changed: ${{ steps.check-changes.outputs.any_changed }}

    steps:
      - name: Checkout remote repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Check microservices tag changes and write env YAMLs
        id: check-changes
        run: |
          set -euo pipefail

          # DEFINIZIONE DEI SERVIZI DI INTERESSE
          services_to_watch=("authorization-server-node" "backend-for-frontend" "api-gateway" "m2m-gateway")
          echo "Exposed services: ${services_to_watch[*]}"
          envs_changed=()
          path_changed_file="temp/apigw-automation-meta"
          mkdir -p "$path_changed_file"

          # CONTROLLO SE ESISTE UN COMMIT PRECEDENTE
          if git rev-parse HEAD~1 >/dev/null 2>&1; then

            # RECUPERO TUTTI I FILE IMAGES.YAML E QUELLI CAMBIATI
            all_files=$(find commons -type f -path '*/images.yaml' | sort)
            changed_files=$(git diff --name-only HEAD~1 HEAD -- 'commons/*/images.yaml')

            # CICLO SU TUTTI I FILE INTERESSATI
            for file in $all_files; do
              if echo "$changed_files" | grep -qx "$file"; then
                env_name=$(echo "$file" | awk -F'/' '{print $2}')
                changes_file="$path_changed_file/changes-${env_name}.yaml"
                > "$changes_file" # PULISCO/CREO IL FILE
                file_has_relevant_changes=false

                # CICLO SU TUTTI I SERVIZI ESPOSTI
                for svc in "${services_to_watch[@]}"; do
                  # RECUPERO I TAG PRIMA E DOPO
                  tag_before=$(git show HEAD~1:$file | yq '.images.microservices["'"$svc"'"].tag' 2>/dev/null || echo "null")
                  tag_after=$(yq '.images.microservices["'"$svc"'"].tag' "$file" 2>/dev/null || echo "null")

                  # SE IL TAG È CAMBIATO, SCRIVO NEL FILE E AGGIUNGO L'AMBIENTE ALLA LISTA
                  if [ "$tag_before" != "$tag_after" ]; then
                    file_has_relevant_changes=true
                    envs_changed+=("$env_name")
                    {
                      echo "${svc}:"
                      echo "  before: $tag_before"
                      echo "  after: $tag_after"
                    } >> "$changes_file"
                  fi
                done

                # SE NESSUN CAMBIAMENTO, ELIMINO IL FILE CREATO VUOTO
                if [ "$file_has_relevant_changes" = false ]; then
                  rm -f "$changes_file"
                fi
              fi
            done

            # RENDO UNICA E ORDINATA LA LISTA DEGLI AMBIENTI COINVOLTI
            set +e
            envs_changed_uniq=($(printf "%s\n" "${envs_changed[@]}" | sort -u | grep -v '^$'))
            set -e

            # ESPORTO I RISULTATI COME OUTPUT DEL JOB, COME ARRAY JSON
            if [ ${#envs_changed_uniq[@]} -gt 0 ]; then
              # output JSON array, sempre valido anche per 1 solo env
              json_envs=$(printf '%s\n' "${envs_changed_uniq[@]}" | jq -R . | jq -s .)
              echo "envs_changed=$(echo "$json_envs" | jq -c .)" >> $GITHUB_OUTPUT
              echo "any_changed=true" >> $GITHUB_OUTPUT
            else
              echo "envs_changed=[]" >> $GITHUB_OUTPUT
              echo "any_changed=false" >> $GITHUB_OUTPUT
            fi

          else
            # SE NON ESISTE UN COMMIT PRECEDENTE, NESSUN CAMBIAMENTO
            echo "No previous commit to compare with."
            echo "envs_changed=[]" >> $GITHUB_OUTPUT
            echo "any_changed=false" >> $GITHUB_OUTPUT
          fi

      - name: Upload changes files as artifact
        # SE CI SONO CAMBIAMENTI, CARICO TUTTI I FILE CHANGES-<ENV>.YAML
        if: ${{ steps.check-changes.outputs.any_changed == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: changes-yamls
          path: temp/apigw-automation-meta/changes-*.yaml

      - name: List artifact dir
        run: |-
          ls -l temp/apigw-automation-meta/

  call-sub-workflow:
    needs: detect-changes
    # ESEGUO SOLO SE ALMENO UN AMBIENTE È CAMBIATO
    if: ${{ needs.detect-changes.outputs.any_changed == 'true' && needs.detect-changes.outputs.envs_changed != '[]' }}
    strategy:
      # CREO LA MATRIX DINAMICA DA ARRAY JSON
      matrix:
        environment: ${{ fromJson(needs.detect-changes.outputs.envs_changed) }}
    uses: ./.github/workflows/apigw-automation-sub.yaml
    with:
      changes_file_path: .apigw-automation-meta/changes-${{ matrix.environment }}.yaml
      environment: ${{ matrix.environment }}
